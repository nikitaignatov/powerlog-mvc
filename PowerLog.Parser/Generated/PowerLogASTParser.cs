//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3 2012-10-19 16:42:46

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019




using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace PowerLog.Parser
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class PowerLogASTParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "DATA", "DIGIT", "EXERCISE", "EXERCISE_NAME", "FLAGGED_SET", "FLAGS", "FLOAT", "FORCED", "FR", "FTL", "LETTER", "MAX", "MESSAGE", "MULTI_SET", "NOTE", "NUMBER", "REP", "RESULT", "SET", "SETS", "SINGLE", "TF", "WEIGHT", "WORD", "WS", "X", "'('", "')'", "'-'", "';'"
	};
	public const int EOF=-1;
	public const int T__30=30;
	public const int T__31=31;
	public const int T__32=32;
	public const int T__33=33;
	public const int DATA=4;
	public const int DIGIT=5;
	public const int EXERCISE=6;
	public const int EXERCISE_NAME=7;
	public const int FLAGGED_SET=8;
	public const int FLAGS=9;
	public const int FLOAT=10;
	public const int FORCED=11;
	public const int FR=12;
	public const int FTL=13;
	public const int LETTER=14;
	public const int MAX=15;
	public const int MESSAGE=16;
	public const int MULTI_SET=17;
	public const int NOTE=18;
	public const int NUMBER=19;
	public const int REP=20;
	public const int RESULT=21;
	public const int SET=22;
	public const int SETS=23;
	public const int SINGLE=24;
	public const int TF=25;
	public const int WEIGHT=26;
	public const int WORD=27;
	public const int WS=28;
	public const int X=29;

	public PowerLogASTParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public PowerLogASTParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return PowerLogASTParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_evaluate();
	partial void LeaveRule_evaluate();

	// $ANTLR start "evaluate"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:36:8: public evaluate : exercise ( ';' exercise )* EOF -> ^( 'result' ( exercise )+ ) ;
	[GrammarRule("evaluate")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> evaluate()
	{
		EnterRule_evaluate();
		EnterRule("evaluate", 1);
		TraceIn("evaluate", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal2 = default(CommonToken);
		CommonToken EOF4 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> exercise1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> exercise3 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal2_tree = default(CommonTree);
		CommonTree EOF4_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleITokenStream stream_33=new RewriteRuleITokenStream(adaptor,"token 33");
		RewriteRuleSubtreeStream stream_exercise=new RewriteRuleSubtreeStream(adaptor,"rule exercise");
		try { DebugEnterRule(GrammarFileName, "evaluate");
		DebugLocation(36, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:37:7: ( exercise ( ';' exercise )* EOF -> ^( 'result' ( exercise )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:37:11: exercise ( ';' exercise )* EOF
			{
			DebugLocation(37, 11);
			PushFollow(Follow._exercise_in_evaluate202);
			exercise1=exercise();
			PopFollow();

			stream_exercise.Add(exercise1.Tree);
			DebugLocation(37, 20);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:37:20: ( ';' exercise )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==33))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:37:21: ';' exercise
					{
					DebugLocation(37, 21);
					char_literal2=(CommonToken)Match(input,33,Follow._33_in_evaluate205);  
					stream_33.Add(char_literal2);

					DebugLocation(37, 25);
					PushFollow(Follow._exercise_in_evaluate207);
					exercise3=exercise();
					PopFollow();

					stream_exercise.Add(exercise3.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(37, 36);
			EOF4=(CommonToken)Match(input,EOF,Follow._EOF_in_evaluate211);  
			stream_EOF.Add(EOF4);



			{
			// AST REWRITE
			// elements: RESULT, exercise
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 37:41: -> ^( 'result' ( exercise )+ )
			{
				DebugLocation(37, 45);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:37:45: ^( 'result' ( exercise )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(37, 47);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RESULT, "RESULT"), root_1);

				DebugLocation(37, 56);
				if (!(stream_exercise.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_exercise.HasNext )
				{
					DebugLocation(37, 56);
					adaptor.AddChild(root_1, stream_exercise.NextTree());

				}
				stream_exercise.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("evaluate", 1);
			LeaveRule("evaluate", 1);
			LeaveRule_evaluate();
		}
		DebugLocation(38, 6);
		} finally { DebugExitRule(GrammarFileName, "evaluate"); }
		return retval;

	}
	// $ANTLR end "evaluate"

	partial void EnterRule_annotatedSet();
	partial void LeaveRule_annotatedSet();

	// $ANTLR start "annotatedSet"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:40:1: annotatedSet : set ( forced | note | flag )* -> ^( 'flagged_set' set ^( 'flags' ( flag )* ( forced )? ( note )? ) ) ;
	[GrammarRule("annotatedSet")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> annotatedSet()
	{
		EnterRule_annotatedSet();
		EnterRule("annotatedSet", 2);
		TraceIn("annotatedSet", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> set5 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> forced6 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> note7 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> flag8 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		RewriteRuleSubtreeStream stream_flag=new RewriteRuleSubtreeStream(adaptor,"rule flag");
		RewriteRuleSubtreeStream stream_set=new RewriteRuleSubtreeStream(adaptor,"rule set");
		RewriteRuleSubtreeStream stream_note=new RewriteRuleSubtreeStream(adaptor,"rule note");
		RewriteRuleSubtreeStream stream_forced=new RewriteRuleSubtreeStream(adaptor,"rule forced");
		try { DebugEnterRule(GrammarFileName, "annotatedSet");
		DebugLocation(40, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:7: ( set ( forced | note | flag )* -> ^( 'flagged_set' set ^( 'flags' ( flag )* ( forced )? ( note )? ) ) )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:11: set ( forced | note | flag )*
			{
			DebugLocation(41, 11);
			PushFollow(Follow._set_in_annotatedSet245);
			set5=set();
			PopFollow();

			stream_set.Add(set5.Tree);
			DebugLocation(41, 15);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:15: ( forced | note | flag )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=4;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==32))
				{
					switch (input.LA(2))
					{
					case FR:
						{
						alt2 = 1;
						}
						break;
					case NOTE:
						{
						alt2 = 2;
						}
						break;
					case FTL:
					case MAX:
					case TF:
						{
						alt2 = 3;
						}
						break;
					}

				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:16: forced
					{
					DebugLocation(41, 16);
					PushFollow(Follow._forced_in_annotatedSet248);
					forced6=forced();
					PopFollow();

					stream_forced.Add(forced6.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:23: note
					{
					DebugLocation(41, 23);
					PushFollow(Follow._note_in_annotatedSet250);
					note7=note();
					PopFollow();

					stream_note.Add(note7.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:28: flag
					{
					DebugLocation(41, 28);
					PushFollow(Follow._flag_in_annotatedSet252);
					flag8=flag();
					PopFollow();

					stream_flag.Add(flag8.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }



			{
			// AST REWRITE
			// elements: note, set, forced, FLAGS, flag, FLAGGED_SET
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 41:41: -> ^( 'flagged_set' set ^( 'flags' ( flag )* ( forced )? ( note )? ) )
			{
				DebugLocation(41, 45);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:45: ^( 'flagged_set' set ^( 'flags' ( flag )* ( forced )? ( note )? ) )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(41, 47);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FLAGGED_SET, "FLAGGED_SET"), root_1);

				DebugLocation(41, 61);
				adaptor.AddChild(root_1, stream_set.NextTree());
				DebugLocation(41, 65);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:65: ^( 'flags' ( flag )* ( forced )? ( note )? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(41, 67);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FLAGS, "FLAGS"), root_2);

				DebugLocation(41, 75);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:75: ( flag )*
				while ( stream_flag.HasNext )
				{
					DebugLocation(41, 75);
					adaptor.AddChild(root_2, stream_flag.NextTree());

				}
				stream_flag.Reset();
				DebugLocation(41, 81);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:81: ( forced )?
				if (stream_forced.HasNext)
				{
					DebugLocation(41, 81);
					adaptor.AddChild(root_2, stream_forced.NextTree());

				}
				stream_forced.Reset();
				DebugLocation(41, 89);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:41:89: ( note )?
				if (stream_note.HasNext)
				{
					DebugLocation(41, 89);
					adaptor.AddChild(root_2, stream_note.NextTree());

				}
				stream_note.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotatedSet", 2);
			LeaveRule("annotatedSet", 2);
			LeaveRule_annotatedSet();
		}
		DebugLocation(42, 6);
		} finally { DebugExitRule(GrammarFileName, "annotatedSet"); }
		return retval;

	}
	// $ANTLR end "annotatedSet"

	partial void EnterRule_set();
	partial void LeaveRule_set();

	// $ANTLR start "set"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:44:1: set : ( sets X reps X weight -> ^( 'multi_set' ^( 'sets' sets ) ^( 'rep' reps ) ^( 'weight' weight ) ) | reps X weight -> ^( 'set' ^( 'rep' reps ) ^( 'weight' weight ) ) | weight -> ^( 'set' ^( 'rep' 'single' ) ^( 'weight' weight ) ) );
	[GrammarRule("set")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> set()
	{
		EnterRule_set();
		EnterRule("set", 3);
		TraceIn("set", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken X10 = default(CommonToken);
		CommonToken X12 = default(CommonToken);
		CommonToken X15 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> sets9 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> reps11 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> weight13 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> reps14 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> weight16 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> weight17 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree X10_tree = default(CommonTree);
		CommonTree X12_tree = default(CommonTree);
		CommonTree X15_tree = default(CommonTree);
		RewriteRuleITokenStream stream_X=new RewriteRuleITokenStream(adaptor,"token X");
		RewriteRuleSubtreeStream stream_reps=new RewriteRuleSubtreeStream(adaptor,"rule reps");
		RewriteRuleSubtreeStream stream_weight=new RewriteRuleSubtreeStream(adaptor,"rule weight");
		RewriteRuleSubtreeStream stream_sets=new RewriteRuleSubtreeStream(adaptor,"rule sets");
		try { DebugEnterRule(GrammarFileName, "set");
		DebugLocation(44, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:45:7: ( sets X reps X weight -> ^( 'multi_set' ^( 'sets' sets ) ^( 'rep' reps ) ^( 'weight' weight ) ) | reps X weight -> ^( 'set' ^( 'rep' reps ) ^( 'weight' weight ) ) | weight -> ^( 'set' ^( 'rep' 'single' ) ^( 'weight' weight ) ) )
			int alt3=3;
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==NUMBER))
			{
				int LA3_1 = input.LA(2);

				if ((LA3_1==X))
				{
					int LA3_3 = input.LA(3);

					if ((LA3_3==NUMBER))
					{
						int LA3_4 = input.LA(4);

						if ((LA3_4==X))
						{
							alt3 = 1;
						}
						else if ((LA3_4==EOF||LA3_4==WS||(LA3_4>=32 && LA3_4<=33)))
						{
							alt3 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 3, 4, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA3_3==FLOAT))
					{
						alt3 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA3_1==EOF||LA3_1==WS||(LA3_1>=32 && LA3_1<=33)))
				{
					alt3 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA3_0==FLOAT))
			{
				alt3 = 3;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:45:11: sets X reps X weight
				{
				DebugLocation(45, 11);
				PushFollow(Follow._sets_in_set313);
				sets9=sets();
				PopFollow();

				stream_sets.Add(sets9.Tree);
				DebugLocation(45, 16);
				X10=(CommonToken)Match(input,X,Follow._X_in_set315);  
				stream_X.Add(X10);

				DebugLocation(45, 18);
				PushFollow(Follow._reps_in_set317);
				reps11=reps();
				PopFollow();

				stream_reps.Add(reps11.Tree);
				DebugLocation(45, 23);
				X12=(CommonToken)Match(input,X,Follow._X_in_set319);  
				stream_X.Add(X12);

				DebugLocation(45, 25);
				PushFollow(Follow._weight_in_set321);
				weight13=weight();
				PopFollow();

				stream_weight.Add(weight13.Tree);


				{
				// AST REWRITE
				// elements: weight, WEIGHT, reps, sets, REP, SETS, MULTI_SET
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 45:41: -> ^( 'multi_set' ^( 'sets' sets ) ^( 'rep' reps ) ^( 'weight' weight ) )
				{
					DebugLocation(45, 45);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:45:45: ^( 'multi_set' ^( 'sets' sets ) ^( 'rep' reps ) ^( 'weight' weight ) )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(45, 47);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(MULTI_SET, "MULTI_SET"), root_1);

					DebugLocation(45, 59);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:45:59: ^( 'sets' sets )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(45, 61);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SETS, "SETS"), root_2);

					DebugLocation(45, 68);
					adaptor.AddChild(root_2, stream_sets.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(45, 74);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:45:74: ^( 'rep' reps )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(45, 76);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REP, "REP"), root_2);

					DebugLocation(45, 82);
					adaptor.AddChild(root_2, stream_reps.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(45, 88);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:45:88: ^( 'weight' weight )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(45, 90);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(WEIGHT, "WEIGHT"), root_2);

					DebugLocation(45, 99);
					adaptor.AddChild(root_2, stream_weight.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:46:11: reps X weight
				{
				DebugLocation(46, 11);
				PushFollow(Follow._reps_in_set367);
				reps14=reps();
				PopFollow();

				stream_reps.Add(reps14.Tree);
				DebugLocation(46, 16);
				X15=(CommonToken)Match(input,X,Follow._X_in_set369);  
				stream_X.Add(X15);

				DebugLocation(46, 18);
				PushFollow(Follow._weight_in_set371);
				weight16=weight();
				PopFollow();

				stream_weight.Add(weight16.Tree);


				{
				// AST REWRITE
				// elements: SET, weight, REP, WEIGHT, reps
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 46:41: -> ^( 'set' ^( 'rep' reps ) ^( 'weight' weight ) )
				{
					DebugLocation(46, 45);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:46:45: ^( 'set' ^( 'rep' reps ) ^( 'weight' weight ) )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(46, 47);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SET, "SET"), root_1);

					DebugLocation(46, 53);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:46:53: ^( 'rep' reps )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(46, 55);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REP, "REP"), root_2);

					DebugLocation(46, 61);
					adaptor.AddChild(root_2, stream_reps.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(46, 67);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:46:67: ^( 'weight' weight )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(46, 69);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(WEIGHT, "WEIGHT"), root_2);

					DebugLocation(46, 78);
					adaptor.AddChild(root_2, stream_weight.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:47:11: weight
				{
				DebugLocation(47, 11);
				PushFollow(Follow._weight_in_set418);
				weight17=weight();
				PopFollow();

				stream_weight.Add(weight17.Tree);


				{
				// AST REWRITE
				// elements: weight, REP, WEIGHT, SET, SINGLE
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 47:41: -> ^( 'set' ^( 'rep' 'single' ) ^( 'weight' weight ) )
				{
					DebugLocation(47, 45);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:47:45: ^( 'set' ^( 'rep' 'single' ) ^( 'weight' weight ) )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(47, 47);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SET, "SET"), root_1);

					DebugLocation(47, 53);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:47:53: ^( 'rep' 'single' )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(47, 55);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REP, "REP"), root_2);

					DebugLocation(47, 61);
					adaptor.AddChild(root_2, (CommonTree)adaptor.Create(SINGLE, "SINGLE"));

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(47, 72);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:47:72: ^( 'weight' weight )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(47, 74);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(WEIGHT, "WEIGHT"), root_2);

					DebugLocation(47, 83);
					adaptor.AddChild(root_2, stream_weight.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("set", 3);
			LeaveRule("set", 3);
			LeaveRule_set();
		}
		DebugLocation(48, 6);
		} finally { DebugExitRule(GrammarFileName, "set"); }
		return retval;

	}
	// $ANTLR end "set"

	partial void EnterRule_exercise();
	partial void LeaveRule_exercise();

	// $ANTLR start "exercise"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:50:1: exercise : exercise_name ( ( WS )+ annotatedSet )* -> ^( 'exercise' ^( 'exercise_name' exercise_name ) ^( 'data' ( annotatedSet )* ) ) ;
	[GrammarRule("exercise")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> exercise()
	{
		EnterRule_exercise();
		EnterRule("exercise", 4);
		TraceIn("exercise", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken WS19 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> exercise_name18 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> annotatedSet20 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree WS19_tree = default(CommonTree);
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_annotatedSet=new RewriteRuleSubtreeStream(adaptor,"rule annotatedSet");
		RewriteRuleSubtreeStream stream_exercise_name=new RewriteRuleSubtreeStream(adaptor,"rule exercise_name");
		try { DebugEnterRule(GrammarFileName, "exercise");
		DebugLocation(50, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:7: ( exercise_name ( ( WS )+ annotatedSet )* -> ^( 'exercise' ^( 'exercise_name' exercise_name ) ^( 'data' ( annotatedSet )* ) ) )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:9: exercise_name ( ( WS )+ annotatedSet )*
			{
			DebugLocation(51, 9);
			PushFollow(Follow._exercise_name_in_exercise483);
			exercise_name18=exercise_name();
			PopFollow();

			stream_exercise_name.Add(exercise_name18.Tree);
			DebugLocation(51, 23);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:23: ( ( WS )+ annotatedSet )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==WS))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:24: ( WS )+ annotatedSet
					{
					DebugLocation(51, 24);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:24: ( WS )+
					int cnt4=0;
					try { DebugEnterSubRule(4);
					while (true)
					{
						int alt4=2;
						try { DebugEnterDecision(4, false);
						int LA4_0 = input.LA(1);

						if ((LA4_0==WS))
						{
							alt4 = 1;
						}


						} finally { DebugExitDecision(4); }
						switch (alt4)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:24: WS
							{
							DebugLocation(51, 24);
							WS19=(CommonToken)Match(input,WS,Follow._WS_in_exercise486);  
							stream_WS.Add(WS19);


							}
							break;

						default:
							if (cnt4 >= 1)
								goto loop4;

							EarlyExitException eee4 = new EarlyExitException( 4, input );
							DebugRecognitionException(eee4);
							throw eee4;
						}
						cnt4++;
					}
					loop4:
						;

					} finally { DebugExitSubRule(4); }

					DebugLocation(51, 28);
					PushFollow(Follow._annotatedSet_in_exercise489);
					annotatedSet20=annotatedSet();
					PopFollow();

					stream_annotatedSet.Add(annotatedSet20.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }



			{
			// AST REWRITE
			// elements: EXERCISE_NAME, EXERCISE, annotatedSet, DATA, exercise_name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 51:50: -> ^( 'exercise' ^( 'exercise_name' exercise_name ) ^( 'data' ( annotatedSet )* ) )
			{
				DebugLocation(51, 54);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:54: ^( 'exercise' ^( 'exercise_name' exercise_name ) ^( 'data' ( annotatedSet )* ) )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(51, 56);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXERCISE, "EXERCISE"), root_1);

				DebugLocation(51, 67);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:67: ^( 'exercise_name' exercise_name )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(51, 69);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXERCISE_NAME, "EXERCISE_NAME"), root_2);

				DebugLocation(51, 85);
				adaptor.AddChild(root_2, stream_exercise_name.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(51, 100);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:100: ^( 'data' ( annotatedSet )* )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(51, 102);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DATA, "DATA"), root_2);

				DebugLocation(51, 109);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:51:109: ( annotatedSet )*
				while ( stream_annotatedSet.HasNext )
				{
					DebugLocation(51, 109);
					adaptor.AddChild(root_2, stream_annotatedSet.NextTree());

				}
				stream_annotatedSet.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exercise", 4);
			LeaveRule("exercise", 4);
			LeaveRule_exercise();
		}
		DebugLocation(52, 6);
		} finally { DebugExitRule(GrammarFileName, "exercise"); }
		return retval;

	}
	// $ANTLR end "exercise"

	partial void EnterRule_flag();
	partial void LeaveRule_flag();

	// $ANTLR start "flag"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:54:1: flag : '-' ! ( MAX | FTL | TF ) ;
	[GrammarRule("flag")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> flag()
	{
		EnterRule_flag();
		EnterRule("flag", 5);
		TraceIn("flag", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal21 = default(CommonToken);
		CommonToken set22 = default(CommonToken);

		CommonTree char_literal21_tree = default(CommonTree);
		CommonTree set22_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "flag");
		DebugLocation(54, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:55:7: ( '-' ! ( MAX | FTL | TF ) )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:55:9: '-' ! ( MAX | FTL | TF )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(55, 12);
			char_literal21=(CommonToken)Match(input,32,Follow._32_in_flag546); 
			DebugLocation(55, 14);

			set22=(CommonToken)input.LT(1);
			if (input.LA(1)==FTL||input.LA(1)==MAX||input.LA(1)==TF)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set22));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("flag", 5);
			LeaveRule("flag", 5);
			LeaveRule_flag();
		}
		DebugLocation(56, 6);
		} finally { DebugExitRule(GrammarFileName, "flag"); }
		return retval;

	}
	// $ANTLR end "flag"

	partial void EnterRule_note();
	partial void LeaveRule_note();

	// $ANTLR start "note"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:58:1: note : '-' NOTE '(' text ')' -> ^( 'note' ^( 'message' text ) ) ;
	[GrammarRule("note")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> note()
	{
		EnterRule_note();
		EnterRule("note", 6);
		TraceIn("note", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal23 = default(CommonToken);
		CommonToken NOTE24 = default(CommonToken);
		CommonToken char_literal25 = default(CommonToken);
		CommonToken char_literal27 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> text26 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal23_tree = default(CommonTree);
		CommonTree NOTE24_tree = default(CommonTree);
		CommonTree char_literal25_tree = default(CommonTree);
		CommonTree char_literal27_tree = default(CommonTree);
		RewriteRuleITokenStream stream_30=new RewriteRuleITokenStream(adaptor,"token 30");
		RewriteRuleITokenStream stream_32=new RewriteRuleITokenStream(adaptor,"token 32");
		RewriteRuleITokenStream stream_31=new RewriteRuleITokenStream(adaptor,"token 31");
		RewriteRuleITokenStream stream_NOTE=new RewriteRuleITokenStream(adaptor,"token NOTE");
		RewriteRuleSubtreeStream stream_text=new RewriteRuleSubtreeStream(adaptor,"rule text");
		try { DebugEnterRule(GrammarFileName, "note");
		DebugLocation(58, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:59:7: ( '-' NOTE '(' text ')' -> ^( 'note' ^( 'message' text ) ) )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:59:9: '-' NOTE '(' text ')'
			{
			DebugLocation(59, 9);
			char_literal23=(CommonToken)Match(input,32,Follow._32_in_note584);  
			stream_32.Add(char_literal23);

			DebugLocation(59, 13);
			NOTE24=(CommonToken)Match(input,NOTE,Follow._NOTE_in_note586);  
			stream_NOTE.Add(NOTE24);

			DebugLocation(59, 18);
			char_literal25=(CommonToken)Match(input,30,Follow._30_in_note588);  
			stream_30.Add(char_literal25);

			DebugLocation(59, 22);
			PushFollow(Follow._text_in_note590);
			text26=text();
			PopFollow();

			stream_text.Add(text26.Tree);
			DebugLocation(59, 27);
			char_literal27=(CommonToken)Match(input,31,Follow._31_in_note592);  
			stream_31.Add(char_literal27);



			{
			// AST REWRITE
			// elements: MESSAGE, NOTE, text
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 59:41: -> ^( 'note' ^( 'message' text ) )
			{
				DebugLocation(59, 45);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:59:45: ^( 'note' ^( 'message' text ) )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(59, 47);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NOTE, "NOTE"), root_1);

				DebugLocation(59, 54);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:59:54: ^( 'message' text )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(59, 56);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(MESSAGE, "MESSAGE"), root_2);

				DebugLocation(59, 66);
				adaptor.AddChild(root_2, stream_text.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("note", 6);
			LeaveRule("note", 6);
			LeaveRule_note();
		}
		DebugLocation(60, 6);
		} finally { DebugExitRule(GrammarFileName, "note"); }
		return retval;

	}
	// $ANTLR end "note"

	partial void EnterRule_forced();
	partial void LeaveRule_forced();

	// $ANTLR start "forced"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:62:1: forced : '-' FR '(' reps ')' -> ^( 'forced' ^( 'rep' reps ) ) ;
	[GrammarRule("forced")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> forced()
	{
		EnterRule_forced();
		EnterRule("forced", 7);
		TraceIn("forced", 7);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal28 = default(CommonToken);
		CommonToken FR29 = default(CommonToken);
		CommonToken char_literal30 = default(CommonToken);
		CommonToken char_literal32 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> reps31 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal28_tree = default(CommonTree);
		CommonTree FR29_tree = default(CommonTree);
		CommonTree char_literal30_tree = default(CommonTree);
		CommonTree char_literal32_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FR=new RewriteRuleITokenStream(adaptor,"token FR");
		RewriteRuleITokenStream stream_30=new RewriteRuleITokenStream(adaptor,"token 30");
		RewriteRuleITokenStream stream_32=new RewriteRuleITokenStream(adaptor,"token 32");
		RewriteRuleITokenStream stream_31=new RewriteRuleITokenStream(adaptor,"token 31");
		RewriteRuleSubtreeStream stream_reps=new RewriteRuleSubtreeStream(adaptor,"rule reps");
		try { DebugEnterRule(GrammarFileName, "forced");
		DebugLocation(62, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:63:7: ( '-' FR '(' reps ')' -> ^( 'forced' ^( 'rep' reps ) ) )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:63:9: '-' FR '(' reps ')'
			{
			DebugLocation(63, 9);
			char_literal28=(CommonToken)Match(input,32,Follow._32_in_forced645);  
			stream_32.Add(char_literal28);

			DebugLocation(63, 13);
			FR29=(CommonToken)Match(input,FR,Follow._FR_in_forced647);  
			stream_FR.Add(FR29);

			DebugLocation(63, 16);
			char_literal30=(CommonToken)Match(input,30,Follow._30_in_forced649);  
			stream_30.Add(char_literal30);

			DebugLocation(63, 20);
			PushFollow(Follow._reps_in_forced651);
			reps31=reps();
			PopFollow();

			stream_reps.Add(reps31.Tree);
			DebugLocation(63, 25);
			char_literal32=(CommonToken)Match(input,31,Follow._31_in_forced653);  
			stream_31.Add(char_literal32);



			{
			// AST REWRITE
			// elements: FORCED, REP, reps
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 63:41: -> ^( 'forced' ^( 'rep' reps ) )
			{
				DebugLocation(63, 45);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:63:45: ^( 'forced' ^( 'rep' reps ) )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(63, 47);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FORCED, "FORCED"), root_1);

				DebugLocation(63, 56);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:63:56: ^( 'rep' reps )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(63, 58);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(REP, "REP"), root_2);

				DebugLocation(63, 64);
				adaptor.AddChild(root_2, stream_reps.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forced", 7);
			LeaveRule("forced", 7);
			LeaveRule_forced();
		}
		DebugLocation(64, 6);
		} finally { DebugExitRule(GrammarFileName, "forced"); }
		return retval;

	}
	// $ANTLR end "forced"

	partial void EnterRule_text();
	partial void LeaveRule_text();

	// $ANTLR start "text"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:66:1: text : WORD ( ( WS !)+ ( WORD | NUMBER ) )* ;
	[GrammarRule("text")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> text()
	{
		EnterRule_text();
		EnterRule("text", 8);
		TraceIn("text", 8);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken WORD33 = default(CommonToken);
		CommonToken WS34 = default(CommonToken);
		CommonToken set35 = default(CommonToken);

		CommonTree WORD33_tree = default(CommonTree);
		CommonTree WS34_tree = default(CommonTree);
		CommonTree set35_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "text");
		DebugLocation(66, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:67:7: ( WORD ( ( WS !)+ ( WORD | NUMBER ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:67:9: WORD ( ( WS !)+ ( WORD | NUMBER ) )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(67, 9);
			WORD33=(CommonToken)Match(input,WORD,Follow._WORD_in_text708); 
			WORD33_tree = (CommonTree)adaptor.Create(WORD33);
			adaptor.AddChild(root_0, WORD33_tree);
			DebugLocation(67, 14);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:67:14: ( ( WS !)+ ( WORD | NUMBER ) )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==WS))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:67:15: ( WS !)+ ( WORD | NUMBER )
					{
					DebugLocation(67, 17);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:67:17: ( WS !)+
					int cnt6=0;
					try { DebugEnterSubRule(6);
					while (true)
					{
						int alt6=2;
						try { DebugEnterDecision(6, false);
						int LA6_0 = input.LA(1);

						if ((LA6_0==WS))
						{
							alt6 = 1;
						}


						} finally { DebugExitDecision(6); }
						switch (alt6)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:67:17: WS !
							{
							DebugLocation(67, 17);
							WS34=(CommonToken)Match(input,WS,Follow._WS_in_text711); 

							}
							break;

						default:
							if (cnt6 >= 1)
								goto loop6;

							EarlyExitException eee6 = new EarlyExitException( 6, input );
							DebugRecognitionException(eee6);
							throw eee6;
						}
						cnt6++;
					}
					loop6:
						;

					} finally { DebugExitSubRule(6); }

					DebugLocation(67, 20);

					set35=(CommonToken)input.LT(1);
					if (input.LA(1)==NUMBER||input.LA(1)==WORD)
					{
						input.Consume();
						adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set35));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("text", 8);
			LeaveRule("text", 8);
			LeaveRule_text();
		}
		DebugLocation(68, 6);
		} finally { DebugExitRule(GrammarFileName, "text"); }
		return retval;

	}
	// $ANTLR end "text"

	partial void EnterRule_exercise_name();
	partial void LeaveRule_exercise_name();

	// $ANTLR start "exercise_name"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:70:1: exercise_name : WORD ( ( WS !)+ WORD )* ;
	[GrammarRule("exercise_name")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> exercise_name()
	{
		EnterRule_exercise_name();
		EnterRule("exercise_name", 9);
		TraceIn("exercise_name", 9);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken WORD36 = default(CommonToken);
		CommonToken WS37 = default(CommonToken);
		CommonToken WORD38 = default(CommonToken);

		CommonTree WORD36_tree = default(CommonTree);
		CommonTree WS37_tree = default(CommonTree);
		CommonTree WORD38_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "exercise_name");
		DebugLocation(70, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:71:7: ( WORD ( ( WS !)+ WORD )* )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:71:9: WORD ( ( WS !)+ WORD )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(71, 9);
			WORD36=(CommonToken)Match(input,WORD,Follow._WORD_in_exercise_name751); 
			WORD36_tree = (CommonTree)adaptor.Create(WORD36);
			adaptor.AddChild(root_0, WORD36_tree);
			DebugLocation(71, 14);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:71:14: ( ( WS !)+ WORD )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				try
				{
					alt9 = dfa9.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:71:15: ( WS !)+ WORD
					{
					DebugLocation(71, 17);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:71:17: ( WS !)+
					int cnt8=0;
					try { DebugEnterSubRule(8);
					while (true)
					{
						int alt8=2;
						try { DebugEnterDecision(8, false);
						int LA8_0 = input.LA(1);

						if ((LA8_0==WS))
						{
							alt8 = 1;
						}


						} finally { DebugExitDecision(8); }
						switch (alt8)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:71:17: WS !
							{
							DebugLocation(71, 17);
							WS37=(CommonToken)Match(input,WS,Follow._WS_in_exercise_name754); 

							}
							break;

						default:
							if (cnt8 >= 1)
								goto loop8;

							EarlyExitException eee8 = new EarlyExitException( 8, input );
							DebugRecognitionException(eee8);
							throw eee8;
						}
						cnt8++;
					}
					loop8:
						;

					} finally { DebugExitSubRule(8); }

					DebugLocation(71, 20);
					WORD38=(CommonToken)Match(input,WORD,Follow._WORD_in_exercise_name758); 
					WORD38_tree = (CommonTree)adaptor.Create(WORD38);
					adaptor.AddChild(root_0, WORD38_tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exercise_name", 9);
			LeaveRule("exercise_name", 9);
			LeaveRule_exercise_name();
		}
		DebugLocation(72, 6);
		} finally { DebugExitRule(GrammarFileName, "exercise_name"); }
		return retval;

	}
	// $ANTLR end "exercise_name"

	partial void EnterRule_weight();
	partial void LeaveRule_weight();

	// $ANTLR start "weight"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:74:1: weight : ( FLOAT | NUMBER );
	[GrammarRule("weight")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> weight()
	{
		EnterRule_weight();
		EnterRule("weight", 10);
		TraceIn("weight", 10);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set39 = default(CommonToken);

		CommonTree set39_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "weight");
		DebugLocation(74, 20);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:75:7: ( FLOAT | NUMBER )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(75, 7);

			set39=(CommonToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==NUMBER)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set39));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("weight", 10);
			LeaveRule("weight", 10);
			LeaveRule_weight();
		}
		DebugLocation(75, 20);
		} finally { DebugExitRule(GrammarFileName, "weight"); }
		return retval;

	}
	// $ANTLR end "weight"

	partial void EnterRule_reps();
	partial void LeaveRule_reps();

	// $ANTLR start "reps"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:77:1: reps : NUMBER ;
	[GrammarRule("reps")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> reps()
	{
		EnterRule_reps();
		EnterRule("reps", 11);
		TraceIn("reps", 11);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NUMBER40 = default(CommonToken);

		CommonTree NUMBER40_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "reps");
		DebugLocation(77, 14);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:78:7: ( NUMBER )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:78:9: NUMBER
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(78, 9);
			NUMBER40=(CommonToken)Match(input,NUMBER,Follow._NUMBER_in_reps810); 
			NUMBER40_tree = (CommonTree)adaptor.Create(NUMBER40);
			adaptor.AddChild(root_0, NUMBER40_tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("reps", 11);
			LeaveRule("reps", 11);
			LeaveRule_reps();
		}
		DebugLocation(78, 14);
		} finally { DebugExitRule(GrammarFileName, "reps"); }
		return retval;

	}
	// $ANTLR end "reps"

	partial void EnterRule_sets();
	partial void LeaveRule_sets();

	// $ANTLR start "sets"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:80:1: sets : NUMBER ;
	[GrammarRule("sets")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> sets()
	{
		EnterRule_sets();
		EnterRule("sets", 12);
		TraceIn("sets", 12);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NUMBER41 = default(CommonToken);

		CommonTree NUMBER41_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "sets");
		DebugLocation(80, 14);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:81:7: ( NUMBER )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\Generated\\PowerLogAST.g3:81:9: NUMBER
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(81, 9);
			NUMBER41=(CommonToken)Match(input,NUMBER,Follow._NUMBER_in_sets830); 
			NUMBER41_tree = (CommonTree)adaptor.Create(NUMBER41);
			adaptor.AddChild(root_0, NUMBER41_tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sets", 12);
			LeaveRule("sets", 12);
			LeaveRule_sets();
		}
		DebugLocation(81, 14);
		} finally { DebugExitRule(GrammarFileName, "sets"); }
		return retval;

	}
	// $ANTLR end "sets"
	#endregion Rules


	#region DFA
	private DFA9 dfa9;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa9 = new DFA9( this );
	}

	private class DFA9 : DFA
	{
		private const string DFA9_eotS =
			"\x4\xFFFF";
		private const string DFA9_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA9_minS =
			"\x1\x1C\x1\xA\x2\xFFFF";
		private const string DFA9_maxS =
			"\x1\x21\x1\x1C\x2\xFFFF";
		private const string DFA9_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA9_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA9_transitionS =
			{
				"\x1\x1\x4\xFFFF\x1\x2",
				"\x1\x2\x8\xFFFF\x1\x2\x7\xFFFF\x1\x3\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
		private static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
		private static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
		private static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
		private static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
		private static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
		private static readonly short[][] DFA9_transition;

		static DFA9()
		{
			int numStates = DFA9_transitionS.Length;
			DFA9_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
			}
		}

		public DFA9( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 9;
			this.eot = DFA9_eot;
			this.eof = DFA9_eof;
			this.min = DFA9_min;
			this.max = DFA9_max;
			this.accept = DFA9_accept;
			this.special = DFA9_special;
			this.transition = DFA9_transition;
		}

		public override string Description { get { return "()* loopback of 71:14: ( ( WS !)+ WORD )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _exercise_in_evaluate202 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_evaluate205 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _exercise_in_evaluate207 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _EOF_in_evaluate211 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_annotatedSet245 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _forced_in_annotatedSet248 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _note_in_annotatedSet250 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _flag_in_annotatedSet252 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _sets_in_set313 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _X_in_set315 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _reps_in_set317 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _X_in_set319 = new BitSet(new ulong[]{0x80400UL});
		public static readonly BitSet _weight_in_set321 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _reps_in_set367 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _X_in_set369 = new BitSet(new ulong[]{0x80400UL});
		public static readonly BitSet _weight_in_set371 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _weight_in_set418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exercise_name_in_exercise483 = new BitSet(new ulong[]{0x10000002UL});
		public static readonly BitSet _WS_in_exercise486 = new BitSet(new ulong[]{0x10080400UL});
		public static readonly BitSet _annotatedSet_in_exercise489 = new BitSet(new ulong[]{0x10000002UL});
		public static readonly BitSet _32_in_flag546 = new BitSet(new ulong[]{0x200A000UL});
		public static readonly BitSet _set_in_flag549 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _32_in_note584 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _NOTE_in_note586 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_note588 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _text_in_note590 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_note592 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _32_in_forced645 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _FR_in_forced647 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _30_in_forced649 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _reps_in_forced651 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _31_in_forced653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WORD_in_text708 = new BitSet(new ulong[]{0x10000002UL});
		public static readonly BitSet _WS_in_text711 = new BitSet(new ulong[]{0x18080000UL});
		public static readonly BitSet _set_in_text715 = new BitSet(new ulong[]{0x10000002UL});
		public static readonly BitSet _WORD_in_exercise_name751 = new BitSet(new ulong[]{0x10000002UL});
		public static readonly BitSet _WS_in_exercise_name754 = new BitSet(new ulong[]{0x18000000UL});
		public static readonly BitSet _WORD_in_exercise_name758 = new BitSet(new ulong[]{0x10000002UL});
		public static readonly BitSet _NUMBER_in_reps810 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_sets830 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace PowerLog.Parser
