grammar PowerLogAST;

options {
	language = CSharp3; 
    TokenLabelType=CommonToken;
    output=AST;
    ASTLabelType=CommonTree;
}
tokens {  
  MULTI_SET='multi_set';
  FLAGGED_SET='flagged_set';
  SET='set';
  SETS='sets';
  REP='rep';
  WEIGHT='weight';
  SINGLE='single';
  FLAGS='flags';
  EXERCISE='exercise';
  EXERCISE_NAME='exercise_name';
  DATA='data';
  NOTE='note';
  FORCED='forced';
  MESSAGE='message';
  RESULT='result';
}

@header {
}

@lexer::header {
}

@lexer::namespace{PowerLog.Parser}
@parser::namespace{PowerLog.Parser}

public evaluate
      :   exercise (';' exercise)* EOF  ->  ^('result' exercise+)
      ;

annotatedSet
      :   set (forced|note|flag)*       ->  ^('flagged_set' set ^('flags' flag* forced? note?))
      ; 
      
set 
      :   sets X reps X weight          ->  ^('multi_set' ^('sets' sets) ^('rep' reps) ^('weight' weight))
      |   reps X weight                 ->  ^('set' ^('rep' reps) ^('weight' weight))
      |   weight                        ->  ^('set' ^('rep' 'single')  ^('weight' weight))
      ;

exercise 
      : exercise_name (WS+ annotatedSet)*        ->  ^('exercise' ^('exercise_name' exercise_name) ^('data' annotatedSet*))
      ;
      
flag 
      : '-'! (MAX|FTL|TF)
      ; 
      
note 
      : '-' NOTE '(' text ')'           ->  ^('note' ^('message' text )) 
      ;
      
forced 
      : '-' FR '(' reps ')'             ->  ^('forced' ^('rep' reps)) 
      ;
      
text  
      : WORD (WS!+ (WORD|NUMBER))* 
      ;
      
exercise_name  
      : WORD (WS!+ WORD)* 
      ;
      
weight
      : FLOAT|NUMBER;
      
reps
      : NUMBER;
      
sets
      : NUMBER;

// lexer


NUMBER: '0'..'9'+;
FLOAT
      :   ('0'..'9')+ '.' ('0'..'9')*     
      |   '.' ('0'..'9')+ 
      ; 
      
X     :  'x' ;

MAX   : 'max';  //  max effort
FTL   : 'ftl';  //  failed to lift
FR    : 'fr';   //  forced reps
TF    : 'tf';   //  to failure
NOTE  : 'note'; //  note
      
fragment
DIGIT
    :  '\u0030'..'\u0039' |
       '\u0660'..'\u0669' |
       '\u06f0'..'\u06f9' |
       '\u0966'..'\u096f' |
       '\u09e6'..'\u09ef' |
       '\u0a66'..'\u0a6f' |
       '\u0ae6'..'\u0aef' |
       '\u0b66'..'\u0b6f' |
       '\u0be7'..'\u0bef' |
       '\u0c66'..'\u0c6f' |
       '\u0ce6'..'\u0cef' |
       '\u0d66'..'\u0d6f' |
       '\u0e50'..'\u0e59' |
       '\u0ed0'..'\u0ed9' |
       '\u1040'..'\u1049'
   ; 
   
fragment
LETTER
    :  '\u0024' |
       '\u0041'..'\u005a' |
       '\u005f' |
       '\u0061'..'\u007a' |
       '\u00c0'..'\u00d6' |
       '\u00d8'..'\u00f6' |
       '\u00f8'..'\u00ff' |
       '\u0100'..'\u1fff' |
       '\u3040'..'\u318f' |
       '\u3300'..'\u337f' |
       '\u3400'..'\u3d2d' |
       '\u4e00'..'\u9fff' |
       '\uf900'..'\ufaff'
    ;
      
WORD  : LETTER(LETTER)*
      ;

WS    : (' ' | '\t' | '\n' | '\r' | '\f')+ 
      ;