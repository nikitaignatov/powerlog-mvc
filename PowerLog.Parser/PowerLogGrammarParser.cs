//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3 2012-10-23 20:51:15

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Globalization;
using System.Linq;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace PowerLog.Parser
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class PowerLogGrammarParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "DIGIT", "FLOAT", "FR", "FTL", "LETTER", "MAX", "NOTE", "NUMBER", "TF", "WORD", "WS", "X", "'('", "')'", "'-'"
	};
	public const int EOF=-1;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int DIGIT=4;
	public const int FLOAT=5;
	public const int FR=6;
	public const int FTL=7;
	public const int LETTER=8;
	public const int MAX=9;
	public const int NOTE=10;
	public const int NUMBER=11;
	public const int TF=12;
	public const int WORD=13;
	public const int WS=14;
	public const int X=15;

	public PowerLogGrammarParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public PowerLogGrammarParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return PowerLogGrammarParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	private sealed partial class annotatedSet_return : AstParserRuleReturnScope<object, IToken>
	{
		public ICollection<Set> result;
		public annotatedSet_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_annotatedSet();
	partial void LeaveRule_annotatedSet();

	// $ANTLR start "annotatedSet"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:20:1: annotatedSet returns [ICollection<Set> result] : set ( ( note ) | ( forced ) | ( flag ) )* ;
	[GrammarRule("annotatedSet")]
	private PowerLogGrammarParser.annotatedSet_return annotatedSet()
	{
		EnterRule_annotatedSet();
		EnterRule("annotatedSet", 1);
		TraceIn("annotatedSet", 1);
		PowerLogGrammarParser.annotatedSet_return retval = new PowerLogGrammarParser.annotatedSet_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		PowerLogGrammarParser.set_return set1 = default(PowerLogGrammarParser.set_return);
		PowerLogGrammarParser.note_return note2 = default(PowerLogGrammarParser.note_return);
		PowerLogGrammarParser.forced_return forced3 = default(PowerLogGrammarParser.forced_return);
		PowerLogGrammarParser.flag_return flag4 = default(PowerLogGrammarParser.flag_return);


					var temp= new Set{};
					retval.result = new List<Set>();
			  
		try { DebugEnterRule(GrammarFileName, "annotatedSet");
		DebugLocation(20, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:26:7: ( set ( ( note ) | ( forced ) | ( flag ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:26:11: set ( ( note ) | ( forced ) | ( flag ) )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(26, 11);
			PushFollow(Follow._set_in_annotatedSet77);
			set1=set();
			PopFollow();

			adaptor.AddChild(root_0, set1.Tree);
			DebugLocation(26, 15);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:26:15: ( ( note ) | ( forced ) | ( flag ) )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=4;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==18))
				{
					switch (input.LA(2))
					{
					case NOTE:
						{
						alt1 = 1;
						}
						break;
					case FR:
						{
						alt1 = 2;
						}
						break;
					case FTL:
					case MAX:
					case TF:
						{
						alt1 = 3;
						}
						break;
					}

				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:26:17: ( note )
					{
					DebugLocation(26, 17);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:26:17: ( note )
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:26:18: note
					{
					DebugLocation(26, 18);
					PushFollow(Follow._note_in_annotatedSet82);
					note2=note();
					PopFollow();

					adaptor.AddChild(root_0, note2.Tree);
					DebugLocation(26, 23);
					temp.Comment=(note2!=null?note2.message:default(string));

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:27:7: ( forced )
					{
					DebugLocation(27, 7);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:27:7: ( forced )
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:27:8: forced
					{
					DebugLocation(27, 8);
					PushFollow(Follow._forced_in_annotatedSet94);
					forced3=forced();
					PopFollow();

					adaptor.AddChild(root_0, forced3.Tree);
					DebugLocation(27, 15);
					temp.ForcedReps=(forced3!=null?forced3.Reps:default(int));

					}


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:28:7: ( flag )
					{
					DebugLocation(28, 7);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:28:7: ( flag )
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:28:8: flag
					{
					DebugLocation(28, 8);
					PushFollow(Follow._flag_in_annotatedSet106);
					flag4=flag();
					PopFollow();

					adaptor.AddChild(root_0, flag4.Tree);
					DebugLocation(28, 13);
					temp.AddFlag((flag4!=null?flag4.text:default(string)));

					}


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(29, 4);

						foreach (var s in (set1!=null?set1.result:default(ICollection<Set>)))
						{
							temp.Reps=s.Reps;
							temp.Weight=s.Weight;
							retval.result.Add(temp.Return());
						}
				  

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotatedSet", 1);
			LeaveRule("annotatedSet", 1);
			LeaveRule_annotatedSet();
		}
		DebugLocation(37, 6);
		} finally { DebugExitRule(GrammarFileName, "annotatedSet"); }
		return retval;

	}
	// $ANTLR end "annotatedSet"

	private sealed partial class set_return : AstParserRuleReturnScope<object, IToken>
	{
		public ICollection<Set> result;
		public set_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_set();
	partial void LeaveRule_set();

	// $ANTLR start "set"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:39:1: set returns [ICollection<Set> result] : ( sets X reps X weight | reps X weight | weight );
	[GrammarRule("set")]
	private PowerLogGrammarParser.set_return set()
	{
		EnterRule_set();
		EnterRule("set", 2);
		TraceIn("set", 2);
		PowerLogGrammarParser.set_return retval = new PowerLogGrammarParser.set_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken X6 = default(IToken);
		IToken X8 = default(IToken);
		IToken X11 = default(IToken);
		PowerLogGrammarParser.sets_return sets5 = default(PowerLogGrammarParser.sets_return);
		PowerLogGrammarParser.reps_return reps7 = default(PowerLogGrammarParser.reps_return);
		PowerLogGrammarParser.weight_return weight9 = default(PowerLogGrammarParser.weight_return);
		PowerLogGrammarParser.reps_return reps10 = default(PowerLogGrammarParser.reps_return);
		PowerLogGrammarParser.weight_return weight12 = default(PowerLogGrammarParser.weight_return);
		PowerLogGrammarParser.weight_return weight13 = default(PowerLogGrammarParser.weight_return);

		object X6_tree = default(object);
		object X8_tree = default(object);
		object X11_tree = default(object);

					retval.result = new List<Set>();
			  
		try { DebugEnterRule(GrammarFileName, "set");
		DebugLocation(39, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:44:7: ( sets X reps X weight | reps X weight | weight )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==NUMBER))
			{
				int LA2_1 = input.LA(2);

				if ((LA2_1==X))
				{
					int LA2_3 = input.LA(3);

					if ((LA2_3==NUMBER))
					{
						int LA2_4 = input.LA(4);

						if ((LA2_4==X))
						{
							alt2 = 1;
						}
						else if ((LA2_4==EOF||LA2_4==WS||LA2_4==18))
						{
							alt2 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 2, 4, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA2_3==FLOAT))
					{
						alt2 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 2, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA2_1==EOF||LA2_1==WS||LA2_1==18))
				{
					alt2 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA2_0==FLOAT))
			{
				alt2 = 3;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:44:11: sets X reps X weight
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(44, 11);
				PushFollow(Follow._sets_in_set160);
				sets5=sets();
				PopFollow();

				adaptor.AddChild(root_0, sets5.Tree);
				DebugLocation(44, 16);
				X6=(IToken)Match(input,X,Follow._X_in_set162); 
				X6_tree = (object)adaptor.Create(X6);
				adaptor.AddChild(root_0, X6_tree);
				DebugLocation(44, 18);
				PushFollow(Follow._reps_in_set164);
				reps7=reps();
				PopFollow();

				adaptor.AddChild(root_0, reps7.Tree);
				DebugLocation(44, 23);
				X8=(IToken)Match(input,X,Follow._X_in_set166); 
				X8_tree = (object)adaptor.Create(X8);
				adaptor.AddChild(root_0, X8_tree);
				DebugLocation(44, 25);
				PushFollow(Follow._weight_in_set168);
				weight9=weight();
				PopFollow();

				adaptor.AddChild(root_0, weight9.Tree);
				DebugLocation(44, 35);
				retval.result.AddRange((sets5!=null?sets5.num:default(int)), new Set{ Reps= (reps7!=null?reps7.num:default(int)),  Weight=(weight9!=null?weight9.num:default(double)) }.Return());

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:45:11: reps X weight
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(45, 11);
				PushFollow(Follow._reps_in_set189);
				reps10=reps();
				PopFollow();

				adaptor.AddChild(root_0, reps10.Tree);
				DebugLocation(45, 16);
				X11=(IToken)Match(input,X,Follow._X_in_set191); 
				X11_tree = (object)adaptor.Create(X11);
				adaptor.AddChild(root_0, X11_tree);
				DebugLocation(45, 18);
				PushFollow(Follow._weight_in_set193);
				weight12=weight();
				PopFollow();

				adaptor.AddChild(root_0, weight12.Tree);
				DebugLocation(45, 30);
				retval.result.Add(new Set{ Reps= (reps10!=null?reps10.num:default(int)),  Weight=(weight12!=null?weight12.num:default(double)) }.Return());

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:46:11: weight
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(46, 11);
				PushFollow(Follow._weight_in_set216);
				weight13=weight();
				PopFollow();

				adaptor.AddChild(root_0, weight13.Tree);
				DebugLocation(46, 24);
				retval.result.Add(new Set{ Reps= 1,			Weight=(weight13!=null?weight13.num:default(double)) }.Return());

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("set", 2);
			LeaveRule("set", 2);
			LeaveRule_set();
		}
		DebugLocation(47, 6);
		} finally { DebugExitRule(GrammarFileName, "set"); }
		return retval;

	}
	// $ANTLR end "set"

	public sealed partial class exercise_return : AstParserRuleReturnScope<object, IToken>
	{
		public Log result;
		public exercise_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_exercise();
	partial void LeaveRule_exercise();

	// $ANTLR start "exercise"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:49:8: public exercise returns [Log result] : text ( ( WS )+ annotatedSet )+ ;
	[GrammarRule("exercise")]
	public PowerLogGrammarParser.exercise_return exercise()
	{
		EnterRule_exercise();
		EnterRule("exercise", 3);
		TraceIn("exercise", 3);
		PowerLogGrammarParser.exercise_return retval = new PowerLogGrammarParser.exercise_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WS15 = default(IToken);
		PowerLogGrammarParser.text_return text14 = default(PowerLogGrammarParser.text_return);
		PowerLogGrammarParser.annotatedSet_return annotatedSet16 = default(PowerLogGrammarParser.annotatedSet_return);

		object WS15_tree = default(object);

		    		retval.result = new Log();
		      
		try { DebugEnterRule(GrammarFileName, "exercise");
		DebugLocation(49, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:54:7: ( text ( ( WS )+ annotatedSet )+ )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:54:9: text ( ( WS )+ annotatedSet )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(54, 9);
			PushFollow(Follow._text_in_exercise275);
			text14=text();
			PopFollow();

			adaptor.AddChild(root_0, text14.Tree);
			DebugLocation(54, 14);
			 retval.result.Name= (text14!=null?text14.text:default(string));
			DebugLocation(54, 43);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:54:43: ( ( WS )+ annotatedSet )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==WS))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:54:44: ( WS )+ annotatedSet
					{
					DebugLocation(54, 44);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:54:44: ( WS )+
					int cnt3=0;
					try { DebugEnterSubRule(3);
					while (true)
					{
						int alt3=2;
						try { DebugEnterDecision(3, false);
						int LA3_0 = input.LA(1);

						if ((LA3_0==WS))
						{
							alt3 = 1;
						}


						} finally { DebugExitDecision(3); }
						switch (alt3)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:54:44: WS
							{
							DebugLocation(54, 44);
							WS15=(IToken)Match(input,WS,Follow._WS_in_exercise280); 
							WS15_tree = (object)adaptor.Create(WS15);
							adaptor.AddChild(root_0, WS15_tree);

							}
							break;

						default:
							if (cnt3 >= 1)
								goto loop3;

							EarlyExitException eee3 = new EarlyExitException( 3, input );
							DebugRecognitionException(eee3);
							throw eee3;
						}
						cnt3++;
					}
					loop3:
						;

					} finally { DebugExitSubRule(3); }

					DebugLocation(54, 48);
					PushFollow(Follow._annotatedSet_in_exercise283);
					annotatedSet16=annotatedSet();
					PopFollow();

					adaptor.AddChild(root_0, annotatedSet16.Tree);
					DebugLocation(54, 61);
					retval.result.Sets.AddRange((annotatedSet16!=null?annotatedSet16.result:default(ICollection<Set>)));

					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exercise", 3);
			LeaveRule("exercise", 3);
			LeaveRule_exercise();
		}
		DebugLocation(55, 6);
		} finally { DebugExitRule(GrammarFileName, "exercise"); }
		return retval;

	}
	// $ANTLR end "exercise"

	private sealed partial class flag_return : AstParserRuleReturnScope<object, IToken>
	{
		public string text;
		public flag_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_flag();
	partial void LeaveRule_flag();

	// $ANTLR start "flag"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:57:1: flag returns [string text] : '-' !f= ( MAX | FTL | TF ) ;
	[GrammarRule("flag")]
	private PowerLogGrammarParser.flag_return flag()
	{
		EnterRule_flag();
		EnterRule("flag", 4);
		TraceIn("flag", 4);
		PowerLogGrammarParser.flag_return retval = new PowerLogGrammarParser.flag_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken f = default(IToken);
		IToken char_literal17 = default(IToken);

		object f_tree = default(object);
		object char_literal17_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "flag");
		DebugLocation(57, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:58:7: ( '-' !f= ( MAX | FTL | TF ) )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:58:9: '-' !f= ( MAX | FTL | TF )
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(58, 12);
			char_literal17=(IToken)Match(input,18,Follow._18_in_flag321); 
			DebugLocation(58, 15);

			f=(IToken)input.LT(1);
			if (input.LA(1)==FTL||input.LA(1)==MAX||input.LA(1)==TF)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(f));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(58, 29);
			retval.text =f.Text;

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("flag", 4);
			LeaveRule("flag", 4);
			LeaveRule_flag();
		}
		DebugLocation(59, 6);
		} finally { DebugExitRule(GrammarFileName, "flag"); }
		return retval;

	}
	// $ANTLR end "flag"

	private sealed partial class note_return : AstParserRuleReturnScope<object, IToken>
	{
		public string message;
		public note_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_note();
	partial void LeaveRule_note();

	// $ANTLR start "note"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:61:1: note returns [string message] : '-' NOTE '(' text ')' ;
	[GrammarRule("note")]
	private PowerLogGrammarParser.note_return note()
	{
		EnterRule_note();
		EnterRule("note", 5);
		TraceIn("note", 5);
		PowerLogGrammarParser.note_return retval = new PowerLogGrammarParser.note_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal18 = default(IToken);
		IToken NOTE19 = default(IToken);
		IToken char_literal20 = default(IToken);
		IToken char_literal22 = default(IToken);
		PowerLogGrammarParser.text_return text21 = default(PowerLogGrammarParser.text_return);

		object char_literal18_tree = default(object);
		object NOTE19_tree = default(object);
		object char_literal20_tree = default(object);
		object char_literal22_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "note");
		DebugLocation(61, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:62:7: ( '-' NOTE '(' text ')' )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:62:9: '-' NOTE '(' text ')'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(62, 9);
			char_literal18=(IToken)Match(input,18,Follow._18_in_note368); 
			char_literal18_tree = (object)adaptor.Create(char_literal18);
			adaptor.AddChild(root_0, char_literal18_tree);
			DebugLocation(62, 13);
			NOTE19=(IToken)Match(input,NOTE,Follow._NOTE_in_note370); 
			NOTE19_tree = (object)adaptor.Create(NOTE19);
			adaptor.AddChild(root_0, NOTE19_tree);
			DebugLocation(62, 18);
			char_literal20=(IToken)Match(input,16,Follow._16_in_note372); 
			char_literal20_tree = (object)adaptor.Create(char_literal20);
			adaptor.AddChild(root_0, char_literal20_tree);
			DebugLocation(62, 22);
			PushFollow(Follow._text_in_note374);
			text21=text();
			PopFollow();

			adaptor.AddChild(root_0, text21.Tree);
			DebugLocation(62, 27);
			char_literal22=(IToken)Match(input,17,Follow._17_in_note376); 
			char_literal22_tree = (object)adaptor.Create(char_literal22);
			adaptor.AddChild(root_0, char_literal22_tree);
			DebugLocation(62, 31);
			retval.message =(text21!=null?text21.text:default(string));

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("note", 5);
			LeaveRule("note", 5);
			LeaveRule_note();
		}
		DebugLocation(63, 6);
		} finally { DebugExitRule(GrammarFileName, "note"); }
		return retval;

	}
	// $ANTLR end "note"

	private sealed partial class forced_return : AstParserRuleReturnScope<object, IToken>
	{
		public int Reps;
		public forced_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_forced();
	partial void LeaveRule_forced();

	// $ANTLR start "forced"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:65:1: forced returns [int Reps] : '-' FR '(' reps ')' ;
	[GrammarRule("forced")]
	private PowerLogGrammarParser.forced_return forced()
	{
		EnterRule_forced();
		EnterRule("forced", 6);
		TraceIn("forced", 6);
		PowerLogGrammarParser.forced_return retval = new PowerLogGrammarParser.forced_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal23 = default(IToken);
		IToken FR24 = default(IToken);
		IToken char_literal25 = default(IToken);
		IToken char_literal27 = default(IToken);
		PowerLogGrammarParser.reps_return reps26 = default(PowerLogGrammarParser.reps_return);

		object char_literal23_tree = default(object);
		object FR24_tree = default(object);
		object char_literal25_tree = default(object);
		object char_literal27_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "forced");
		DebugLocation(65, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:66:7: ( '-' FR '(' reps ')' )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:66:9: '-' FR '(' reps ')'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(66, 9);
			char_literal23=(IToken)Match(input,18,Follow._18_in_forced409); 
			char_literal23_tree = (object)adaptor.Create(char_literal23);
			adaptor.AddChild(root_0, char_literal23_tree);
			DebugLocation(66, 13);
			FR24=(IToken)Match(input,FR,Follow._FR_in_forced411); 
			FR24_tree = (object)adaptor.Create(FR24);
			adaptor.AddChild(root_0, FR24_tree);
			DebugLocation(66, 16);
			char_literal25=(IToken)Match(input,16,Follow._16_in_forced413); 
			char_literal25_tree = (object)adaptor.Create(char_literal25);
			adaptor.AddChild(root_0, char_literal25_tree);
			DebugLocation(66, 20);
			PushFollow(Follow._reps_in_forced415);
			reps26=reps();
			PopFollow();

			adaptor.AddChild(root_0, reps26.Tree);
			DebugLocation(66, 25);
			char_literal27=(IToken)Match(input,17,Follow._17_in_forced417); 
			char_literal27_tree = (object)adaptor.Create(char_literal27);
			adaptor.AddChild(root_0, char_literal27_tree);
			DebugLocation(66, 30);
			retval.Reps =(reps26!=null?reps26.num:default(int));

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forced", 6);
			LeaveRule("forced", 6);
			LeaveRule_forced();
		}
		DebugLocation(67, 6);
		} finally { DebugExitRule(GrammarFileName, "forced"); }
		return retval;

	}
	// $ANTLR end "forced"

	private sealed partial class text_return : AstParserRuleReturnScope<object, IToken>
	{
		public string text;
		public text_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_text();
	partial void LeaveRule_text();

	// $ANTLR start "text"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:69:1: text returns [string text] : a= WORD ( ( WS !)+ b= WORD )* ;
	[GrammarRule("text")]
	private PowerLogGrammarParser.text_return text()
	{
		EnterRule_text();
		EnterRule("text", 7);
		TraceIn("text", 7);
		PowerLogGrammarParser.text_return retval = new PowerLogGrammarParser.text_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken a = default(IToken);
		IToken b = default(IToken);
		IToken WS28 = default(IToken);

		object a_tree = default(object);
		object b_tree = default(object);
		object WS28_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "text");
		DebugLocation(69, 6);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:70:7: (a= WORD ( ( WS !)+ b= WORD )* )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:70:9: a= WORD ( ( WS !)+ b= WORD )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(70, 10);
			a=(IToken)Match(input,WORD,Follow._WORD_in_text454); 
			a_tree = (object)adaptor.Create(a);
			adaptor.AddChild(root_0, a_tree);
			DebugLocation(70, 15);
			retval.text = a.Text;
			DebugLocation(70, 34);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:70:34: ( ( WS !)+ b= WORD )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				try
				{
					alt6 = dfa6.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:70:35: ( WS !)+ b= WORD
					{
					DebugLocation(70, 37);
					// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:70:37: ( WS !)+
					int cnt5=0;
					try { DebugEnterSubRule(5);
					while (true)
					{
						int alt5=2;
						try { DebugEnterDecision(5, false);
						int LA5_0 = input.LA(1);

						if ((LA5_0==WS))
						{
							alt5 = 1;
						}


						} finally { DebugExitDecision(5); }
						switch (alt5)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:70:37: WS !
							{
							DebugLocation(70, 37);
							WS28=(IToken)Match(input,WS,Follow._WS_in_text458); 

							}
							break;

						default:
							if (cnt5 >= 1)
								goto loop5;

							EarlyExitException eee5 = new EarlyExitException( 5, input );
							DebugRecognitionException(eee5);
							throw eee5;
						}
						cnt5++;
					}
					loop5:
						;

					} finally { DebugExitSubRule(5); }

					DebugLocation(70, 41);
					b=(IToken)Match(input,WORD,Follow._WORD_in_text464); 
					b_tree = (object)adaptor.Create(b);
					adaptor.AddChild(root_0, b_tree);
					DebugLocation(70, 47);
					retval.text +=" " + b.Text;

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("text", 7);
			LeaveRule("text", 7);
			LeaveRule_text();
		}
		DebugLocation(71, 6);
		} finally { DebugExitRule(GrammarFileName, "text"); }
		return retval;

	}
	// $ANTLR end "text"

	private sealed partial class weight_return : AstParserRuleReturnScope<object, IToken>
	{
		public double num;
		public weight_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_weight();
	partial void LeaveRule_weight();

	// $ANTLR start "weight"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:73:1: weight returns [double num] : n= ( FLOAT | NUMBER ) ;
	[GrammarRule("weight")]
	private PowerLogGrammarParser.weight_return weight()
	{
		EnterRule_weight();
		EnterRule("weight", 8);
		TraceIn("weight", 8);
		PowerLogGrammarParser.weight_return retval = new PowerLogGrammarParser.weight_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken n = default(IToken);

		object n_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "weight");
		DebugLocation(73, 105);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:74:7: (n= ( FLOAT | NUMBER ) )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:74:9: n= ( FLOAT | NUMBER )
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(74, 10);

			n=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==NUMBER)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(n));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(74, 26);
			retval.num = double.Parse(n.Text,NumberStyles.Float, CultureInfo.InvariantCulture);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("weight", 8);
			LeaveRule("weight", 8);
			LeaveRule_weight();
		}
		DebugLocation(74, 105);
		} finally { DebugExitRule(GrammarFileName, "weight"); }
		return retval;

	}
	// $ANTLR end "weight"

	private sealed partial class reps_return : AstParserRuleReturnScope<object, IToken>
	{
		public int num;
		public reps_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_reps();
	partial void LeaveRule_reps();

	// $ANTLR start "reps"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:76:1: reps returns [int num] : NUMBER ;
	[GrammarRule("reps")]
	private PowerLogGrammarParser.reps_return reps()
	{
		EnterRule_reps();
		EnterRule("reps", 9);
		TraceIn("reps", 9);
		PowerLogGrammarParser.reps_return retval = new PowerLogGrammarParser.reps_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUMBER29 = default(IToken);

		object NUMBER29_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "reps");
		DebugLocation(76, 48);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:77:7: ( NUMBER )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:77:9: NUMBER
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(77, 9);
			NUMBER29=(IToken)Match(input,NUMBER,Follow._NUMBER_in_reps533); 
			NUMBER29_tree = (object)adaptor.Create(NUMBER29);
			adaptor.AddChild(root_0, NUMBER29_tree);
			DebugLocation(77, 16);
			retval.num = int.Parse(NUMBER29.Text);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("reps", 9);
			LeaveRule("reps", 9);
			LeaveRule_reps();
		}
		DebugLocation(77, 48);
		} finally { DebugExitRule(GrammarFileName, "reps"); }
		return retval;

	}
	// $ANTLR end "reps"

	private sealed partial class sets_return : AstParserRuleReturnScope<object, IToken>
	{
		public int num;
		public sets_return(PowerLogGrammarParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PowerLogGrammarParser grammar);
	}

	partial void EnterRule_sets();
	partial void LeaveRule_sets();

	// $ANTLR start "sets"
	// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:79:1: sets returns [int num] : NUMBER ;
	[GrammarRule("sets")]
	private PowerLogGrammarParser.sets_return sets()
	{
		EnterRule_sets();
		EnterRule("sets", 10);
		TraceIn("sets", 10);
		PowerLogGrammarParser.sets_return retval = new PowerLogGrammarParser.sets_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUMBER30 = default(IToken);

		object NUMBER30_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "sets");
		DebugLocation(79, 48);
		try
		{
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:80:7: ( NUMBER )
			DebugEnterAlt(1);
			// C:\\Users\\Bacon\\Documents\\Visual Studio 2012\\Projects\\REPO\\PowerLog\\PowerLog.Parser\\PowerLogGrammar.g3:80:9: NUMBER
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(80, 9);
			NUMBER30=(IToken)Match(input,NUMBER,Follow._NUMBER_in_sets560); 
			NUMBER30_tree = (object)adaptor.Create(NUMBER30);
			adaptor.AddChild(root_0, NUMBER30_tree);
			DebugLocation(80, 16);
			retval.num = int.Parse(NUMBER30.Text);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sets", 10);
			LeaveRule("sets", 10);
			LeaveRule_sets();
		}
		DebugLocation(80, 48);
		} finally { DebugExitRule(GrammarFileName, "sets"); }
		return retval;

	}
	// $ANTLR end "sets"
	#endregion Rules


	#region DFA
	private DFA6 dfa6;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa6 = new DFA6( this );
	}

	private class DFA6 : DFA
	{
		private const string DFA6_eotS =
			"\x4\xFFFF";
		private const string DFA6_eofS =
			"\x4\xFFFF";
		private const string DFA6_minS =
			"\x1\xE\x1\x5\x2\xFFFF";
		private const string DFA6_maxS =
			"\x1\x11\x1\xE\x2\xFFFF";
		private const string DFA6_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA6_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA6_transitionS =
			{
				"\x1\x1\x2\xFFFF\x1\x2",
				"\x1\x2\x5\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\x1",
				"",
				""
			};

		private static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
		private static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
		private static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
		private static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
		private static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
		private static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
		private static readonly short[][] DFA6_transition;

		static DFA6()
		{
			int numStates = DFA6_transitionS.Length;
			DFA6_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
			}
		}

		public DFA6( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 6;
			this.eot = DFA6_eot;
			this.eof = DFA6_eof;
			this.min = DFA6_min;
			this.max = DFA6_max;
			this.accept = DFA6_accept;
			this.special = DFA6_special;
			this.transition = DFA6_transition;
		}

		public override string Description { get { return "()* loopback of 70:34: ( ( WS !)+ b= WORD )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _set_in_annotatedSet77 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _note_in_annotatedSet82 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _forced_in_annotatedSet94 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _flag_in_annotatedSet106 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _sets_in_set160 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _X_in_set162 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _reps_in_set164 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _X_in_set166 = new BitSet(new ulong[]{0x820UL});
		public static readonly BitSet _weight_in_set168 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _reps_in_set189 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _X_in_set191 = new BitSet(new ulong[]{0x820UL});
		public static readonly BitSet _weight_in_set193 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _weight_in_set216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _text_in_exercise275 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _WS_in_exercise280 = new BitSet(new ulong[]{0x4820UL});
		public static readonly BitSet _annotatedSet_in_exercise283 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _18_in_flag321 = new BitSet(new ulong[]{0x1280UL});
		public static readonly BitSet _set_in_flag326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _18_in_note368 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _NOTE_in_note370 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _16_in_note372 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _text_in_note374 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_note376 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _18_in_forced409 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _FR_in_forced411 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _16_in_forced413 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _reps_in_forced415 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_forced417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WORD_in_text454 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _WS_in_text458 = new BitSet(new ulong[]{0x6000UL});
		public static readonly BitSet _WORD_in_text464 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _set_in_weight502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_reps533 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_sets560 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace PowerLog.Parser
